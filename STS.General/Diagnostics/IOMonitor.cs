using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace STS.General.Diagnostics
{
    /// <summary>
    /// Provides an IO monitoring for a process.
    /// </summary>
    public class IOMonitor
    {
        private Timer timer;

        private PerformanceCounter writesCounter;
        private PerformanceCounter readsCounter;
        private PerformanceCounter dataCounter;

        private bool monitorIOWrites;
        private bool monitorIOReads;
        private bool monitorIOData;

        private long sampleCounter;

        private float totalIOWrites;
        private float totalIOReads;
        private float totalIOData;

        private float averageIOWrites;
        private float averageIOReads;
        private float averageIOData;

        private long monitorPerionInMilliseconds;

        public IOMonitor(bool monitorIOWrites, bool monitorIOReads, bool monitorIOData, int monitorPeriodInMilliseconds)
        {
            if (!monitorIOWrites && !monitorIOReads && !monitorIOData)
                throw new ArgumentException("At least one flag has to be true.");

            this.monitorIOWrites = monitorIOWrites;
            this.monitorIOReads = monitorIOReads;
            this.monitorIOData = monitorIOData;

            this.monitorPerionInMilliseconds = monitorPeriodInMilliseconds;

            string processName = Process.GetCurrentProcess().ProcessName;

            if(monitorIOWrites)
                writesCounter = new PerformanceCounter("Process", "IO Write Bytes/sec", processName);
            if(monitorIOReads)
                readsCounter = new PerformanceCounter("Process", "IO Read Bytes/sec", processName);
            if(monitorIOData)
                dataCounter = new PerformanceCounter("Process", "IO Data Bytes/sec", processName);

            timer = new Timer(DoMonitor, null, Timeout.Infinite, MonitorPeriodInMilliseconds);
        }

        public IOMonitor(int monitorPeriodInMilliseconds = 1000)
            :this(true, true, true, monitorPeriodInMilliseconds)
        {
        }

        private void DoMonitor(object state)
        {
            sampleCounter++;

            if (monitorIOWrites)
            {
                IOWriteBytes = writesCounter.NextValue();

                totalIOWrites += IOWriteBytes;
                averageIOWrites = totalIOWrites / sampleCounter;
            }

            if (monitorIOReads)
            {
                IOReadBytes = readsCounter.NextValue();

                totalIOReads += IOReadBytes;
                averageIOReads = totalIOReads / sampleCounter;
            }

            if (monitorIOData)
            {
                IODataBytes = dataCounter.NextValue();

                totalIOData += IODataBytes;
                averageIOData = totalIOData / sampleCounter;
            }
        }

        public void Start()
        {
            timer.Change(0, MonitorPeriodInMilliseconds);
        }

        public void Stop()
        {
            timer.Change(Timeout.Infinite, Timeout.Infinite);
        }

        public void Reset()
        {
            IOWriteBytes = 0;
            IOReadBytes = 0;
            IODataBytes = 0;

            sampleCounter = 0;

            totalIOWrites = 0;
            totalIOReads = 0;
            totalIOData = 0;

            averageIOWrites = 0;
            averageIOReads = 0;
            averageIOData = 0;
        }

        /// <summary>
        /// Gets or sets the interval between every measure.
        /// </summary>
        public long MonitorPeriodInMilliseconds
        {
            get { return monitorPerionInMilliseconds; }
            set
            {
                monitorPerionInMilliseconds = value;
                timer.Change(0, monitorPerionInMilliseconds);
            }
        }

        /// <summary>
        /// Shows the rate, in incidents per second, at which the process was writing bytes to I/O operations. 
        /// It counts all I/O activity generated by the process including file, network, and device I/Os.
        /// </summary>
        public float IOWriteBytes { get; private set; }

        /// <summary>
        /// Shows the rate, in incidents per second, at which the process was reading bytes from I/O operations. 
        /// It counts all I/O activity generated by the process including file, network, and device I/Os.
        /// </summary>
        public float IOReadBytes { get; private set; }

        /// <summary>
        /// Shows the rate, in incidents per second, at which the process was reading and writing bytes in I/O operations. 
        /// It counts all I/O activity generated by the process including file, network, and device I/Os.
        /// </summary>
        public float IODataBytes { get; private set; }

        /// <summary>
        /// Gets the average IOWriteBytes.
        /// </summary>
        public float AverageIOWriteBytes 
        {
            get { return averageIOWrites; }
        }

        /// <summary>
        /// Gets the average IOReadBytes.
        /// </summary>
        public float AverageIOReadBytes
        {
            get { return averageIOReads; }
        }

        /// <summary>
        /// Gets the average IODataBytes.
        /// </summary>
        public float AverageIODataBytes 
        {
            get { return averageIOData; }
        }
    }
}
